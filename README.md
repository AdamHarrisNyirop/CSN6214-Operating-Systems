# CSN6214 OPERATING SYSTEMS - TRIMESTER 2530 (CONCURRENT NETWORKED BOARD GAME INTERPRETER)

## Submission Date

#### 8th February 2026, Sunday, 5:00 PM, Week 14

## Team Size

####  3 to 4 members and must be from the same tutorial or lab section

## Project Overview & Goal

#### You will design and implement a multiplayer, text-based board game for 3 to 5 players using a hybrid concurrency model that combines multiprocessing and multithreading. The system must also support the playing of multiple, successive games without requiring a full server restart. This assignment demonstrates advanced understanding of:
- Multiprocessing via fork() for client isolation
- Multithreading for internal server tasks (e.g., logging, scheduling)
- Inter-Process Communication (IPC)
- Synchronization across threads and processes (using mutexes, semaphores)
- Round Robin (RR) scheduling for turn management
- Concurrent, safe logging of all game events

#### You may choose your own turn-based, text-based game, provided it meets the constraints in Section 2. The system must support one of the following deployment modes:
- Single-machine mode: All components on one host; client-server communication via IPC (e.g., named pipes, message queues)
- Multi-machine mode: Clients and server on different machines; communication via TCP sockets (IPv4)

#### Hybrid concurrency is mandatory: Your server must use both fork() (for clients) AND POSIX threads (pthreads) for internal coordination.

## Game Requirements (Student-Selected)

#### Select any turn-based, text-based game that satisfies:
- Supports exactly 3 to 5 players
- Server-enforced rules (no client-side validation)
- Text-only CLI interface
- Clear win/loss/draw condition
- Moderate complexity (variants of Tic-Tac-Toe, simplified card games, race games, word games)
- All randomness (dice, cards) must be generated by the server only

## Mandatory Concurrency Model: Hybrid (fork + Threads)

#### Your server must combine:

### Multiprocessing (fork())
- For each client that connects or joins, the server forks a child process to handle that player’s session
- The parent process must reap zombies (e.g., using SIGCHLD + waitpid())

### Multithreading (pthreads)
- The main server process (parent) must create at least two internal threads to handle:
- Round Robin turn scheduler (manages whose turn it is and advances turns)
- Concurrent logger (writes all game events to game.log)
- These threads must run concurrently with the main accept loop and with each other
- Threads must coordinate safely with fork()ed children via shared memory and synchronization primitives

## Logger Requirements (Thread-Safe & Concurrent)
- Log all events to game.log: connections, moves, turn changes, game end
- The logger must run in its own thread
- All log messages must be:
- Complete (no interleaving)
- Ordered (chronologically consistent)
- Non-blocking to gameplay
- Use synchronization (e.g., a mutex or semaphore) to protect the log queue or file access across threads and processes

## Round Robin Scheduler (Thread-Based)
- Adedicated scheduler thread in the parent process must:
- Maintain the cyclic player order
- Determine the current player’s turn– Signal when a player may act
- Turn state must reside in shared memory so fork()ed children can read it
- All updates to turn state must be synchronized (mutex/semaphore) and visible across processes
- The scheduler must skip disconnected/inactive players

## Architectural & Synchronization Requirements

### Interprocess Communication (IPC) & Communication
- Shared game state (board, positions, turn, etc.) must reside in POSIX shared memory
- In single-machine mode, client-server communication uses IPC (e.g., named pipes)
- In multi-machine mode, client-server uses TCP, but server internals still use shared memory + threads

### Synchronization Across Domains
- You must use both:
- Process-shared mutexes/semaphores (for fork()ed children ↔ parent threads)
- Thread mutexes (for internal thread coordination, if needed)
- All access to shared memory (by threads or child processes) must be mutually exclusive
- Initialize shared mutexes with PTHREAD PROCESS SHARED

## Persistent Scoring & History

#### The server must implement a persistent scoring mechanism to track player statistics across sessions.

### Scores File Requirements
- Persistent Storage: The server must maintain player win statistics in a file named scores.txt.
- Loading: The server must load the scores.txt file into shared memory upon server startup. If the file does not exist, it should be created
- Updating: At the conclusion of every game, the winning player’s score must be atomically updated in the shared memory structure.
- Saving: Theservermustwrite the updated scores from memory back to scores.txt upon server shutdown (using signal handling, e.g., SIGINT) and potentially after every completed game

### Concurrency & Synchronization
- The in-memory score structure is a critical shared resource
- All read and write operations on the score structure must be protected using the Process-Shared Mutexes/Semaphores to prevent race conditions, especially when game-end events are triggered by child processes

## Deliverables

### Source Code (C/C++)
- server.c, client.c, Makefile
- Must use fork() and pthread_create()
- Compile on Linux with gcc -pthread

### Design Report (PDF, 10-15 pages)
- Game description and rules
- Deployment mode (IPC or TCP)
- Hybrid architecture: diagram showing processes, threads, and data flow
- IPC mechanism and shared memory layout
- Synchronization strategy: how mutexes/semaphores coordinate threads and processes
- Logger design: thread structure, queue, safety
- RR scheduler: how the thread manages turns across processes
- Persistence Strategy: Describe the file format, the loading/saving mechanism for scores.txt, and the synchronization used to protect the in-memory score data
- Multi-Game Handling: Explain how the server resets and re-initializes for the start of a new game
- Testing evidence: gameplay screenshots + sample game.log
- Screenshots: screenshots of each client view, part of the logger, and persistent storage content
